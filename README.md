# CS-300-DSA

# Data Structures and Algorithms - Reflection

## Problem Statement

In these projects, I tackled the challenge of understanding and applying data structures to solve real-world problems. For Project One, I analyzed the run-time and memory efficiency of different data structures, focusing on their Big O performance. In Project Two, I developed a C++ program that sorts and prints a list of Computer Science courses in alphanumeric order, a task that required careful selection of data structures to optimize for performance and memory usage.

## Approach

My approach to solving these problems revolved around selecting the most appropriate data structures based on the specific requirements of each task. Understanding data structures is crucial because they directly influence the efficiency of algorithms and, consequently, the performance of the software. In Project One, I compared various data structures, including vectors, hash tables, and trees, to identify the best fit for different scenarios. For Project Two, I chose a structure that allowed for efficient sorting and retrieval of course information.

## Overcoming Roadblocks

During these projects, I encountered several roadblocks, particularly in optimizing code and ensuring that my implementations were both efficient and correct. To overcome these challenges, I leveraged debugging tools, revisited foundational concepts in data structures, and continuously tested my code to identify and fix issues. Persistence and methodical troubleshooting were key to resolving the issues I faced.

## Expanded Approach to Software Design

Working on these projects has significantly expanded my approach to software design and development. I have gained a deeper understanding of how to select the right data structures based on specific use cases, which has improved the efficiency and scalability of my programs. These projects also reinforced the importance of considering both run-time and memory constraints when designing software.

## Evolution in Writing Maintainable Code

My work on these projects has evolved the way I write programs to be more maintainable, readable, and adaptable. I've become more disciplined in using clear and consistent coding practices, including proper naming conventions, modularization, and documentation. These practices not only make the code easier to understand and modify but also ensure that it can be easily extended or refactored in the future.

